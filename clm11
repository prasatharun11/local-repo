private static List<String> partitionChunks(List<String> entries, int chunkLimit, boolean byLength, int numChunks) {
    List<String> chunks = new ArrayList<>(Collections.nCopies(numChunks, ""));
    
    if (byLength) {
        // ---- Length-based (Programs) ----
        StringBuilder currentChunk = new StringBuilder();
        int chunkIndex = 0;
        
        for (String entry : entries) {
            String remainingEntry = entry;
            
            while (!remainingEntry.isEmpty() && chunkIndex < numChunks) {
                int availableSpace = chunkLimit - currentChunk.length();
                
                if (availableSpace <= 0) {
                    // Current chunk is full, finalize it
                    chunks.set(chunkIndex, currentChunk.toString());
                    chunkIndex++;
                    currentChunk = new StringBuilder();
                    availableSpace = chunkLimit;
                }
                
                if (remainingEntry.length() <= availableSpace) {
                    // Entire entry fits in current chunk
                    currentChunk.append(remainingEntry);
                    remainingEntry = "";
                } else {
                    // Entry doesn't fit completely, need to split carefully
                    int splitIndex = findSafeSplitIndex(remainingEntry, availableSpace);
                    
                    if (splitIndex == 0) {
                        // Cannot split at all, need to move entire entry to next chunk
                        if (currentChunk.length() > 0) {
                            chunks.set(chunkIndex, currentChunk.toString());
                            chunkIndex++;
                            currentChunk = new StringBuilder();
                        }
                        currentChunk.append(remainingEntry);
                        remainingEntry = "";
                    } else {
                        // Split at safe position
                        String partToAdd = remainingEntry.substring(0, splitIndex);
                        currentChunk.append(partToAdd);
                        remainingEntry = remainingEntry.substring(splitIndex);
                        
                        // Finalize current chunk if it's now full
                        if (currentChunk.length() >= chunkLimit) {
                            chunks.set(chunkIndex, currentChunk.toString());
                            chunkIndex++;
                            currentChunk = new StringBuilder();
                        }
                    }
                }
            }
            
            if (chunkIndex >= numChunks) {
                break;
            }
        }
        
        // Add the last chunk if there's content and space
        if (chunkIndex < numChunks && currentChunk.length() > 0) {
            chunks.set(chunkIndex, currentChunk.toString());
            chunkIndex++;
        }
        
        // Fill remaining chunks with "~"
        for (int i = chunkIndex; i < numChunks; i++) {
            chunks.set(i, "~");
        }
        
    } else {
        // ---- Count-based (Policies) ----
        AtomicInteger counter = new AtomicInteger(0);
        entries.stream()
                .collect(Collectors.groupingBy(s -> counter.getAndIncrement() / chunkLimit))
                .forEach((idx, group) -> {
                    if (idx < numChunks) {
                        String joined = String.join("", group);
                        if (!joined.endsWith("~")) joined += "~";
                        chunks.set(idx, joined);
                    }
                });
        // Fill empty chunks with "~"
        for (int i = 0; i < numChunks; i++) {
            if (chunks.get(i).isEmpty()) chunks.set(i, "~");
        }
    }
    
    return chunks;
}

private static int findSafeSplitIndex(String text, int maxLength) {
    if (maxLength >= text.length()) {
        return text.length();
    }
    
    // Check if we're in the middle of a program code (P-123456789)
    if (maxLength >= 2 && text.startsWith("P-")) {
        // Program code starts with "P-" followed by digits
        int programCodeEnd = text.indexOf('|');
        if (programCodeEnd != -1 && programCodeEnd < maxLength) {
            // We can include the complete program code
            return programCodeEnd + 1; // Include the '|'
        } else if (programCodeEnd != -1 && programCodeEnd >= maxLength) {
            // Program code doesn't fit, don't split it
            return 0;
        }
    }
    
    // Check if we're in the middle of a 3-digit code
    if (maxLength > 0) {
        // Look for the last safe split position (either '~' or '|')
        for (int i = Math.min(maxLength, text.length()); i > 0; i--) {
            char currentChar = text.charAt(i - 1);
            
            // Safe to split after '~' or '|'
            if (currentChar == '~' || currentChar == '|') {
                return i;
            }
            
            // Don't split in the middle of a 3-digit code
            if (i % 3 == 0 && i + 2 < text.length()) {
                // Check if we're at the end of a 3-digit code
                char nextChar = text.charAt(i);
                if (nextChar == '~' || nextChar == '|') {
                    return i;
                }
            }
        }
    }
    
    // If no safe split found, return 0 (don't split)
    return 0;
}

// Helper method to handle chunk starts with ~ or |
private static void handleChunkStartsWithSpecialChar(List<String> chunks) {
    for (int i = 1; i < chunks.size(); i++) {
        String currentChunk = chunks.get(i);
        String previousChunk = chunks.get(i - 1);
        
        if (currentChunk.startsWith("~") && !previousChunk.isEmpty()) {
            // Move last country code from previous chunk to current chunk
            int lastTilde = previousChunk.lastIndexOf('~');
            if (lastTilde != -1 && lastTilde < previousChunk.length() - 1) {
                String lastCountryCode = previousChunk.substring(lastTilde + 1);
                chunks.set(i - 1, previousChunk.substring(0, lastTilde + 1));
                chunks.set(i, lastCountryCode + currentChunk.substring(1));
            }
        } else if (currentChunk.startsWith("|") && !previousChunk.isEmpty()) {
            // Move last program code from previous chunk to current chunk
            int lastPipe = previousChunk.lastIndexOf('|');
            if (lastPipe != -1) {
                String lastProgramCode = previousChunk.substring(lastPipe);
                chunks.set(i - 1, previousChunk.substring(0, lastPipe));
                chunks.set(i, lastProgramCode + currentChunk.substring(1));
            }
        }
    }
}