import com.fasterxml.jackson.databind.ObjectMapper;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class OptimizedProgramProcessor {

    private static final int PROGRAM_CHUNK_SIZE = 32000;  // char-based chunking
    private static final int POLICY_CHUNK_SIZE = 1450;
    private static final int POLICY_MAX_LIMIT = 4350;

    public static Map<String, String> processProgramResponse(String json) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        ProgramResponse response = mapper.readValue(json, ProgramResponse.class);

        Map<String, String> result = new LinkedHashMap<>();
        result.put("userType", response.getUserType());

        // --- Program chunks (non-USA) ---
        List<String> programEntries = Optional.ofNullable(response.getNonUsaPrograms())
                .orElse(Collections.emptyList())
                .stream()
                .map(program -> {
                    String countries = Optional.ofNullable(program.getPolicyCountryCodes())
                            .orElse(Collections.emptyList())
                            .stream()
                            .collect(Collectors.joining(""));
                    return program.getProgramID() + "|" + countries + "~";
                })
                .collect(Collectors.toList());

        List<String> programChunks = partitionProgramChunks(programEntries, PROGRAM_CHUNK_SIZE);

        // --- Policy chunks (USA) ---
        DateTimeFormatter inputFmt = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
        DateTimeFormatter outputFmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");

        List<String> policyEntries = Optional.ofNullable(response.getUsaPrograms())
                .orElse(Collections.emptyList())
                .stream()
                .flatMap(program -> Optional.ofNullable(program.getPolicies()).orElse(Collections.emptyList()).stream())
                .limit(POLICY_MAX_LIMIT)
                .map(policy -> {
                    String formattedDate = LocalDateTime.parse(policy.getPolicyEffectiveDate(), inputFmt).format(outputFmt);
                    return policy.getPolicyId() + "|" + formattedDate + "~";
                })
                .collect(Collectors.toList());

        String[] policyChunks = partitionPolicyChunks(policyEntries, POLICY_CHUNK_SIZE, 3);

        // --- Add to result ---
        AtomicInteger index = new AtomicInteger(1);
        programChunks.forEach(chunk -> result.put("programChunk" + index.getAndIncrement(), chunk));

        for (int i = 0; i < policyChunks.length; i++) {
            result.put("policyChunk" + (i + 1), policyChunks[i]);
        }

        result.put("totalProgramCount", String.valueOf(programEntries.size()));
        result.put("totalPolicyCount", String.valueOf(policyEntries.size()));

        return result;
    }

    private static List<String> partitionProgramChunks(List<String> entries, int maxChunkSize) {
        List<String> chunks = new ArrayList<>();
        StringBuilder current = new StringBuilder();

        for (String entry : entries) {
            if (current.length() + entry.length() > maxChunkSize) {
                // close current chunk
                if (current.length() > 0 && current.charAt(current.length() - 1) != '~') {
                    current.append("~");
                }
                chunks.add(current.toString());
                current = new StringBuilder();
            }
            current.append(entry);
        }

        if (current.length() > 0) {
            if (current.charAt(current.length() - 1) != '~') {
                current.append("~");
            }
            chunks.add(current.toString());
        }

        // Ensure even empty chunks still have ~
        if (chunks.isEmpty()) {
            chunks.add("~");
        }

        return chunks;
    }

    private static String[] partitionPolicyChunks(List<String> entries, int chunkSize, int numChunks) {
        String[] chunks = new String[numChunks];
        Arrays.fill(chunks, "~");
        AtomicInteger counter = new AtomicInteger(0);

        entries.stream()
                .collect(Collectors.groupingBy(s -> counter.getAndIncrement() / chunkSize))
                .forEach((chunkIndex, chunkEntries) -> {
                    if (chunkIndex < numChunks) {
                        chunks[chunkIndex] = String.join("", chunkEntries);
                    }
                });

        return chunks;
    }
}