import com.fasterxml.jackson.databind.ObjectMapper;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class OptimizedProgramProcessor {

    private static final int PROGRAM_MAX_LENGTH = 32000;
    private static final int POLICY_CHUNK_SIZE = 1450;

    public static Map<String, String> processProgramResponse(String json) throws Exception {
        ObjectMapper mapper = new ObjectMapper();
        ProgramResponse response = mapper.readValue(json, ProgramResponse.class);

        Map<String, String> result = new LinkedHashMap<>();
        result.put("userType", response.getUserType());

        // ---- PROGRAM ENTRIES ----
        List<String> nonUsaProgramEntries = Optional.ofNullable(response.getNonUsaPrograms())
                .orElse(Collections.emptyList())
                .stream()
                .map(program -> {
                    // Deduplicate policyCountryCodes
                    Set<String> uniqueCountries = Optional.ofNullable(program.getPolicyCountryCodes())
                            .orElse(Collections.emptyList())
                            .stream()
                            .collect(Collectors.toCollection(LinkedHashSet::new));
                    String countries = String.join("", uniqueCountries);
                    return program.getProgramID() + "|" + countries + "~";
                })
                .collect(Collectors.toList());

        List<String> programChunks = partitionChunks(nonUsaProgramEntries, PROGRAM_MAX_LENGTH, true, 10);

        // ---- POLICY ENTRIES ----
        DateTimeFormatter inputFmt = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSZ");
        DateTimeFormatter outputFmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");

        List<String> usaPolicyEntries = Optional.ofNullable(response.getUsaPrograms())
                .orElse(Collections.emptyList())
                .stream()
                .flatMap(program -> Optional.ofNullable(program.getPolicies())
                        .orElse(Collections.emptyList())
                        .stream())
                .map(policy -> {
                    String formattedDate = LocalDateTime.parse(policy.getPolicyEffectiveDate(), inputFmt).format(outputFmt);
                    return policy.getPolicyId() + "|" + formattedDate + "~";
                })
                .collect(Collectors.toList());

        List<String> policyChunks = partitionChunks(usaPolicyEntries, POLICY_CHUNK_SIZE, false, 3);

        // ---- PUT RESULTS ----
        result.put("programChunk1", programChunks.get(0));
        result.put("programChunk2", programChunks.get(1));
        // Add more if needed up to 10
        for (int i = 3; i <= programChunks.size(); i++) {
            result.put("programChunk" + i, programChunks.get(i - 1));
        }

        result.put("policyChunk1", policyChunks.get(0));
        result.put("policyChunk2", policyChunks.get(1));
        result.put("policyChunk3", policyChunks.get(2));

        result.put("totalProgramCount", String.valueOf(nonUsaProgramEntries.size()));
        result.put("totalPolicyCount", String.valueOf(usaPolicyEntries.size()));

        return result;
    }

    /**
     * Unified partitioner for both program (by length) and policy (by count).
     */
    private static List<String> partitionChunks(List<String> entries, int chunkLimit, boolean byLength, int numChunks) {
        List<String> chunks = new ArrayList<>(Collections.nCopies(numChunks, ""));

        if (byLength) {
            // ---- Length-based (Programs) ----
            StringBuilder current = new StringBuilder();
            int chunkIndex = 0;
            for (String entry : entries) {
                if (current.length() + entry.length() > chunkLimit && chunkIndex < numChunks) {
                    if (current.length() == 0) {
                        chunks.set(chunkIndex, entry);
                    } else {
                        if (current.charAt(current.length() - 1) != '~') current.append("~");
                        chunks.set(chunkIndex, current.toString());
                        chunkIndex++;
                        current = new StringBuilder(entry);
                    }
                } else {
                    current.append(entry);
                }
            }
            if (chunkIndex < numChunks) {
                if (current.length() == 0 || current.charAt(current.length() - 1) != '~') current.append("~");
                chunks.set(chunkIndex, current.toString());
            }
            // Fill empty chunks with "~"
            for (int i = 0; i < numChunks; i++) {
                if (chunks.get(i).isEmpty()) chunks.set(i, "~");
            }
        } else {
            // ---- Count-based (Policies) ----
            AtomicInteger counter = new AtomicInteger(0);
            entries.stream()
                    .collect(Collectors.groupingBy(s -> counter.getAndIncrement() / chunkLimit))
                    .forEach((idx, group) -> {
                        if (idx < numChunks) {
                            String joined = String.join("", group);
                            if (!joined.endsWith("~")) joined += "~";
                            chunks.set(idx, joined);
                        }
                    });
            // Fill empty chunks with "~"
            for (int i = 0; i < numChunks; i++) {
                if (chunks.get(i).isEmpty()) chunks.set(i, "~");
            }
        }

        return chunks;
    }
}