private static List<String> partitionChunks(List<String> entries, int chunkLimit, boolean byLength, int numChunks) {
    List<String> chunks = new ArrayList<>(Collections.nCopies(numChunks, ""));
    
    if (byLength) {
        // ---- Length-based (Programs) ----
        StringBuilder currentChunk = new StringBuilder();
        int chunkIndex = 0;
        
        for (String entry : entries) {
            String remainingEntry = entry;
            
            while (!remainingEntry.isEmpty() && chunkIndex < numChunks) {
                int availableSpace = chunkLimit - currentChunk.length();
                
                if (availableSpace <= 0) {
                    // Current chunk is full, finalize it
                    chunks.set(chunkIndex, currentChunk.toString());
                    chunkIndex++;
                    currentChunk = new StringBuilder();
                    availableSpace = chunkLimit;
                }
                
                if (remainingEntry.length() <= availableSpace) {
                    // Entire entry fits in current chunk
                    currentChunk.append(remainingEntry);
                    remainingEntry = "";
                } else {
                    // Entry doesn't fit completely, need to split carefully
                    int splitIndex = findSafeSplitIndex(remainingEntry, availableSpace);
                    
                    if (splitIndex == 0) {
                        // Cannot split at all, need to move entire entry to next chunk
                        if (currentChunk.length() > 0) {
                            chunks.set(chunkIndex, currentChunk.toString());
                            chunkIndex++;
                            currentChunk = new StringBuilder();
                        }
                        currentChunk.append(remainingEntry);
                        remainingEntry = "";
                    } else {
                        // Split at safe position
                        String partToAdd = remainingEntry.substring(0, splitIndex);
                        currentChunk.append(partToAdd);
                        remainingEntry = remainingEntry.substring(splitIndex);
                        
                        // Finalize current chunk if it's now full
                        if (currentChunk.length() >= chunkLimit) {
                            chunks.set(chunkIndex, currentChunk.toString());
                            chunkIndex++;
                            currentChunk = new StringBuilder();
                        }
                    }
                }
            }
            
            if (chunkIndex >= numChunks) {
                break;
            }
        }
        
        // Add the last chunk if there's content and space
        if (chunkIndex < numChunks && currentChunk.length() > 0) {
            chunks.set(chunkIndex, currentChunk.toString());
            chunkIndex++;
        }
        
        // Fill remaining chunks with "~"
        for (int i = chunkIndex; i < numChunks; i++) {
            chunks.set(i, "~");
        }
        
        // Handle chunks that start with ~ or |
        for (int i = 1; i < chunks.size(); i++) {
            String currentChunk = chunks.get(i);
            String previousChunk = chunks.get(i - 1);
            
            if (currentChunk.startsWith("~") && !previousChunk.isEmpty()) {
                // Move only the last 3-digit country code from previous chunk to current chunk
                int lastTilde = previousChunk.lastIndexOf('~');
                if (lastTilde != -1 && lastTilde < previousChunk.length() - 3) {
                    // Extract only the last 3-digit country code (before the ~)
                    String lastCountryCode = previousChunk.substring(previousChunk.length() - 3);
                    chunks.set(i - 1, previousChunk.substring(0, previousChunk.length() - 3));
                    chunks.set(i, lastCountryCode + currentChunk.substring(1));
                }
            } else if (currentChunk.startsWith("|") && !previousChunk.isEmpty()) {
                // Move only the last program code from previous chunk to current chunk
                int lastPipe = previousChunk.lastIndexOf('|');
                if (lastPipe != -1) {
                    // Extract only the program code after the last pipe
                    String lastProgramCode = previousChunk.substring(lastPipe);
                    chunks.set(i - 1, previousChunk.substring(0, lastPipe));
                    chunks.set(i, lastProgramCode + currentChunk.substring(1));
                }
            }
        }
        
    } else {
        // ---- Count-based (Policies) ----
        AtomicInteger counter = new AtomicInteger(0);
        entries.stream()
                .collect(Collectors.groupingBy(s -> counter.getAndIncrement() / chunkLimit))
                .forEach((idx, group) -> {
                    if (idx < numChunks) {
                        String joined = String.join("", group);
                        if (!joined.endsWith("~")) joined += "~";
                        chunks.set(idx, joined);
                    }
                });
        // Fill empty chunks with "~"
        for (int i = 0; i < numChunks; i++) {
            if (chunks.get(i).isEmpty()) chunks.set(i, "~");
        }
    }
    
    return chunks;
}

private static int findSafeSplitIndex(String text, int maxLength) {
    if (maxLength >= text.length()) {
        return text.length();
    }
    
    // Check if we're in the middle of a program code (P-123456789)
    if (maxLength >= 2 && text.startsWith("P-")) {
        int programCodeEnd = text.indexOf('|');
        if (programCodeEnd != -1 && programCodeEnd < maxLength) {
            return programCodeEnd + 1; // Include the '|'
        } else if (programCodeEnd != -1 && programCodeEnd >= maxLength) {
            return 0; // Don't split the program code
        }
    }
    
    // Check if we're in the middle of a 3-digit code
    if (maxLength > 0) {
        // Look for the last safe split position (either '~' or '|')
        for (int i = Math.min(maxLength, text.length()); i > 0; i--) {
            char currentChar = text.charAt(i - 1);
            
            // Safe to split after '~' or '|'
            if (currentChar == '~' || currentChar == '|') {
                return i;
            }
            
            // Don't split in the middle of a 3-digit code
            // Check if we're at the end of a 3-digit code (position divisible by 3)
            if (i % 3 == 0 && i < text.length()) {
                char nextChar = text.charAt(i);
                if (nextChar == '~' || nextChar == '|') {
                    return i;
                }
            }
        }
    }
    
    // If no safe split found, return 0 (don't split)
    return 0;
}